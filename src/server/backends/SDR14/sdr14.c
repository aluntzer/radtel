/**
 * @file    server/backends/SDR14/sdr14.c
 * @author  Armin Luntzer (armin.luntzer@univie.ac.at)
 *
 * @copyright GPLv2
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * @brief plugin for sdr14 with ftdi_sio kernel module
 *
 */


#include <stdio.h>
#include <stdlib.h>

#include <glib.h>
#include <glib/gstdio.h>

#include <gmodule.h>
#include <string.h>

#include <backend.h>
#include <cmd.h>
#include <ack.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <poll.h>
#include <fftw3.h>


#include <termios.h>



static char *sdr14_tty = "/dev/ttyUSB0";
static int sdr14_fd;


#define AVG 10
#define NSAM  2048	/* 2048 16 bit I/Q pairs (in AD66220 mode)  */

int Status;
int freq_A2D = 66666666; /* this is only relevant in real non-AD6620 mode */


double *reamin0, *reamout0;
fftw_plan p0;

/* I'm beginning to suspect that we use too many locks :D */
static GThread *thread;
static GCond	acq_cond;
static GMutex   acq_lock;
static GMutex   acq_pause;
static GRWLock  obs_rwlock;


#define MSG "SDR14 SPEC: "

#define SDR14_HDR_LEN	2
/* SDR14 data items are fixed for type 0 data items (I/Q or real samples) */
#define SDR14_DATA0_LEN	4096

struct sdr14_data_pkt {
	uint8_t  hdr[SDR14_HDR_LEN];
	int16_t data[SDR14_DATA0_LEN];
};


/**
 * @brief flush pending bytes
 */

static void sdr14_serial_flush(int fd)
{
	int n;
	unsigned char c;

	printf("flushing...");
	while ((n = read(fd, &c, sizeof(c))) > 0);
	printf("done\n");
}


/**
 * @brief open a serial tty
 * @param tty the path to the tty
 *
 * @return 0 on error, file descriptor otherwise
 */

static int sdr14_serial_open_port(const char *tty)
{
	int fd;


	fd = open(tty, O_RDWR);

	if (fd < 0) {
		perror("unable to open serial port");
		return 0;
	}


	return fd;
}

/**
 * @brief set the serial link parameters for the SDR14 with the ftdi_sio module
 *
 * @param fd the file descriptor of the serial tty
 *
 * @return see man 3 tcsetattr
 */

static int sdr14_serial_set_comm_param(int fd)
{
	struct termios cfg = {0};


	/* we start from a cleared struct, so we need only set our config */
	cfg.c_cflag = CS8 | CLOCAL | CREAD;
        cfg.c_iflag = IGNPAR;

        cfsetispeed(&cfg, B230400);
        cfsetospeed(&cfg, B230400);

        cfg.c_cc[VTIME] = 1;

	/* set configuration */
	return tcsetattr (fd, TCSANOW, &cfg);
}



static int myread(size_t left, uint8_t *p)
{
	size_t n = 0;
	while (left > 0)
	{
		ssize_t nr = read(sdr14_fd, p, left);
		if (nr <= 0) 	{
			if (nr < 0)
				perror("read");  /* Error! */
			break;
		}
		else {
			n += nr;     /* We have read some more data */
			left -= nr;     /* Less data left to read */
			p += nr; /* So we don't read over already read data */
		}
	}

}


static int sdr14_read(struct sdr14_data_pkt *pkt)
{
	uint8_t ack[8];
	uint8_t *p;
#if 0
	uint8_t oneshot_cmd[8] = {0x08, 0x00, 0x18, 0x00, 0x81, 0x02, 0x02, 0x01};





	write(sdr14_fd, oneshot_cmd, sizeof(oneshot_cmd));

	/*  read ack */
	n = read(sdr14_fd, ack, sizeof(ack));
#endif
	/*  read data sample */




	size_t n = 0;
	size_t left = sizeof(struct sdr14_data_pkt);  /* The total size of the buffer */
	p = (uint8_t *) pkt;
	while (left > 0)
	{
		ssize_t nr = read(sdr14_fd, p, left);
		if (nr <= 0) 	{
			if (nr < 0)
				perror("read");  /* Error! */
			break;
		}
		else {
			n += nr;     /* We have read some more data */
			left -= nr;     /* Less data left to read */
			p += nr; /* So we don't read over already read data */
		}
	}


#if 0
	/*  read unsolicited receive state */
	read(sdr14_fd, ack, sizeof(ack));

	/*  read unsolicited receive state idle */
	read(sdr14_fd, ack, sizeof(ack));
#endif

	return 0;
}

static void sdr14_get_mode(void)
{
	uint8_t cmd[6] = {0x50, 0x20, 0x18, 0x00, 0x00};

	printf("reading mode\n");

	write(sdr14_fd, cmd, sizeof(cmd));

	read(sdr14_fd, cmd, sizeof(cmd));

	printf("ack was %x\n", cmd[5]);

}

static void sdr14_setup_ad6620(void)
{
	int i, n;
	uint8_t cmd[9] = {0x09, 0xa0, 0, 0, 0, 0, 0, 0, 0};
	uint8_t ack[3];

	uint8_t pld[1869] = {0x0,0x3,0x9,0x0,0x0,0x0,0x0,0x1,0x3,0x6,0x0,0x0,0x0,0x0,0x5,0x3,0x5,0x0,0x0,0x0,0x0,0x6,0x3,0x9,0x0,0x0,0x0,0x0,0x7,0x3,0x10,0x0,0x0,0x0,0x0,0x8,0x3,0x10,0x0,0x0,0x0,0x0,0xa,0x3,0x1,0x0,0x0,0x0,0x0,0xb,0x3,0x0,0x0,0x0,0x0,0x0,0xc,0x3,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x32,0xff,0xff,0xff,0x0,0x1,0x0,0x43,0xfd,0xff,0xff,0x0,0x2,0x0,0x11,0xfc,0xff,0xff,0x0,0x3,0x0,0x76,0xfd,0xff,0xff,0x0,0x4,0x0,0x96,0x0,0x0,0x0,0x0,0x5,0x0,0xce,0x1,0x0,0x0,0x0,0x6,0x0,0x1a,0x0,0x0,0x0,0x0,0x7,0x0,0x97,0xfe,0xff,0xff,0x0,0x8,0x0,0xb8,0xff,0xff,0xff,0x0,0x9,0x0,0x39,0x1,0x0,0x0,0x0,0xa,0x0,0x5f,0x0,0x0,0x0,0x0,0xb,0x0,0xd4,0xfe,0xff,0xff,0x0,0xc,0x0,0x90,0xff,0xff,0xff,0x0,0xd,0x0,0x2c,0x1,0x0,0x0,0x0,0xe,0x0,0x83,0x0,0x0,0x0,0x0,0xf,0x0,0xc9,0xfe,0xff,0xff,0x0,0x10,0x0,0x65,0xff,0xff,0xff,0x0,0x11,0x0,0x46,0x1,0x0,0x0,0x0,0x12,0x0,0xb7,0x0,0x0,0x0,0x0,0x13,0x0,0xa8,0xfe,0xff,0xff,0x0,0x14,0x0,0x29,0xff,0xff,0xff,0x0,0x15,0x0,0x6c,0x1,0x0,0x0,0x0,0x16,0x0,0xfc,0x0,0x0,0x0,0x0,0x17,0x0,0x7f,0xfe,0xff,0xff,0x0,0x18,0x0,0xd9,0xfe,0xff,0xff,0x0,0x19,0x0,0x97,0x1,0x0,0x0,0x0,0x1a,0x0,0x55,0x1,0x0,0x0,0x0,0x1b,0x0,0x55,0xfe,0xff,0xff,0x0,0x1c,0x0,0x77,0xfe,0xff,0xff,0x0,0x1d,0x0,0xc0,0x1,0x0,0x0,0x0,0x1e,0x0,0xc2,0x1,0x0,0x0,0x0,0x1f,0x0,0x2d,0xfe,0xff,0xff,0x0,0x20,0x0,0x0,0xfe,0xff,0xff,0x0,0x21,0x0,0xe5,0x1,0x0,0x0,0x0,0x22,0x0,0x43,0x2,0x0,0x0,0x0,0x23,0x0,0xa,0xfe,0xff,0xff,0x0,0x24,0x0,0x75,0xfd,0xff,0xff,0x0,0x25,0x0,0x5,0x2,0x0,0x0,0x0,0x26,0x0,0xd9,0x2,0x0,0x0,0x0,0x27,0x0,0xef,0xfd,0xff,0xff,0x0,0x28,0x0,0xd3,0xfc,0xff,0xff,0x0,0x29,0x0,0x1b,0x2,0x0,0x0,0x0,0x2a,0x0,0x86,0x3,0x0,0x0,0x0,0x2b,0x0,0xdd,0xfd,0xff,0xff,0x0,0x2c,0x0,0x1a,0xfc,0xff,0xff,0x0,0x2d,0x0,0x26,0x2,0x0,0x0,0x0,0x2e,0x0,0x4c,0x4,0x0,0x0,0x0,0x2f,0x0,0xd9,0xfd,0xff,0xff,0x0,0x30,0x0,0x47,0xfb,0xff,0xff,0x0,0x31,0x0,0x23,0x2,0x0,0x0,0x0,0x32,0x0,0x2c,0x5,0x0,0x0,0x0,0x33,0x0,0xe6,0xfd,0xff,0xff,0x0,0x34,0x0,0x5a,0xfa,0xff,0xff,0x0,0x35,0x0,0xd,0x2,0x0,0x0,0x0,0x36,0x0,0x27,0x6,0x0,0x0,0x0,0x37,0x0,0x6,0xfe,0xff,0xff,0x0,0x38,0x0,0x50,0xf9,0xff,0xff,0x0,0x39,0x0,0xe1,0x1,0x0,0x0,0x0,0x3a,0x0,0x40,0x7,0x0,0x0,0x0,0x3b,0x0,0x3e,0xfe,0xff,0xff,0x0,0x3c,0x0,0x28,0xf8,0xff,0xff,0x0,0x3d,0x0,0x9c,0x1,0x0,0x0,0x0,0x3e,0x0,0x7a,0x8,0x0,0x0,0x0,0x3f,0x0,0x94,0xfe,0xff,0xff,0x0,0x40,0x0,0xde,0xf6,0xff,0xff,0x0,0x41,0x0,0x37,0x1,0x0,0x0,0x0,0x42,0x0,0xd6,0x9,0x0,0x0,0x0,0x43,0x0,0xa,0xff,0xff,0xff,0x0,0x44,0x0,0x6f,0xf5,0xff,0xff,0x0,0x45,0x0,0xac,0x0,0x0,0x0,0x0,0x46,0x0,0x57,0xb,0x0,0x0,0x0,0x47,0x0,0xa9,0xff,0xff,0xff,0x0,0x48,0x0,0xd8,0xf3,0xff,0xff,0x0,0x49,0x0,0xf5,0xff,0xff,0xff,0x0,0x4a,0x0,0x4,0xd,0x0,0x0,0x0,0x4b,0x0,0x7b,0x0,0x0,0x0,0x0,0x4c,0x0,0x14,0xf2,0xff,0xff,0x0,0x4d,0x0,0x8,0xff,0xff,0xff,0x0,0x4e,0x0,0xe2,0xe,0x0,0x0,0x0,0x4f,0x0,0x85,0x1,0x0,0x0,0x0,0x50,0x0,0x19,0xf0,0xff,0xff,0x0,0x51,0x0,0xda,0xfd,0xff,0xff,0x0,0x52,0x0,0xfa,0x10,0x0,0x0,0x0,0x53,0x0,0xda,0x2,0x0,0x0,0x0,0x54,0x0,0xe1,0xed,0xff,0xff,0x0,0x55,0x0,0x5c,0xfc,0xff,0xff,0x0,0x56,0x0,0x57,0x13,0x0,0x0,0x0,0x57,0x0,0x87,0x4,0x0,0x0,0x0,0x58,0x0,0x5a,0xeb,0xff,0xff,0x0,0x59,0x0,0x79,0xfa,0xff,0xff,0x0,0x5a,0x0,0xd,0x16,0x0,0x0,0x0,0x5b,0x0,0xa9,0x6,0x0,0x0,0x0,0x5c,0x0,0x70,0xe8,0xff,0xff,0x0,0x5d,0x0,0x10,0xf8,0xff,0xff,0x0,0x5e,0x0,0x33,0x19,0x0,0x0,0x0,0x5f,0x0,0x63,0x9,0x0,0x0,0x0,0x60,0x0,0x3,0xe5,0xff,0xff,0x0,0x61,0x0,0xf6,0xf4,0xff,0xff,0x0,0x62,0x0,0xf5,0x1c,0x0,0x0,0x0,0x63,0x0,0xef,0xc,0x0,0x0,0x0,0x64,0x0,0xdc,0xe0,0xff,0xff,0x0,0x65,0x0,0xe0,0xf0,0xff,0xff,0x0,0x66,0x0,0x96,0x21,0x0,0x0,0x0,0x67,0x0,0xaf,0x11,0x0,0x0,0x0,0x68,0x0,0xa6,0xdb,0xff,0xff,0x0,0x69,0x0,0x4d,0xeb,0xff,0xff,0x0,0x6a,0x0,0x88,0x27,0x0,0x0,0x0,0x6b,0x0,0x4e,0x18,0x0,0x0,0x0,0x6c,0x0,0xc3,0xd4,0xff,0xff,0x0,0x6d,0x0,0x50,0xe3,0xff,0xff,0x0,0x6e,0x0,0xa5,0x2f,0x0,0x0,0x0,0x6f,0x0,0x23,0x22,0x0,0x0,0x0,0x70,0x0,0xfe,0xca,0xff,0xff,0x0,0x71,0x0,0xe8,0xd6,0xff,0xff,0x0,0x72,0x0,0xb7,0x3b,0x0,0x0,0x0,0x73,0x0,0x4a,0x32,0x0,0x0,0x0,0x74,0x0,0x99,0xbb,0xff,0xff,0x0,0x75,0x0,0xfa,0xc0,0xff,0xff,0x0,0x76,0x0,0x28,0x50,0x0,0x0,0x0,0x77,0x0,0xd8,0x51,0x0,0x0,0x0,0x78,0x0,0xf5,0x9e,0xff,0xff,0x0,0x79,0x0,0x97,0x8f,0xff,0xff,0x0,0x7a,0x0,0x58,0x7b,0x0,0x0,0x0,0x7b,0x0,0x2b,0xaa,0x0,0x0,0x0,0x7c,0x0,0xcb,0x56,0xff,0xff,0x0,0x7d,0x0,0xcf,0xc5,0xfe,0xff,0x0,0x7e,0x0,0x5b,0x1,0x1,0x0,0x0,0x7f,0x0,0x0,0x0,0x4,0x0,0x0,0x80,0x0,0x0,0x0,0x4,0x0,0x0,0x81,0x0,0x5b,0x1,0x1,0x0,0x0,0x82,0x0,0xcf,0xc5,0xfe,0xff,0x0,0x83,0x0,0xcb,0x56,0xff,0xff,0x0,0x84,0x0,0x2b,0xaa,0x0,0x0,0x0,0x85,0x0,0x58,0x7b,0x0,0x0,0x0,0x86,0x0,0x97,0x8f,0xff,0xff,0x0,0x87,0x0,0xf5,0x9e,0xff,0xff,0x0,0x88,0x0,0xd8,0x51,0x0,0x0,0x0,0x89,0x0,0x28,0x50,0x0,0x0,0x0,0x8a,0x0,0xfa,0xc0,0xff,0xff,0x0,0x8b,0x0,0x99,0xbb,0xff,0xff,0x0,0x8c,0x0,0x4a,0x32,0x0,0x0,0x0,0x8d,0x0,0xb7,0x3b,0x0,0x0,0x0,0x8e,0x0,0xe8,0xd6,0xff,0xff,0x0,0x8f,0x0,0xfe,0xca,0xff,0xff,0x0,0x90,0x0,0x23,0x22,0x0,0x0,0x0,0x91,0x0,0xa5,0x2f,0x0,0x0,0x0,0x92,0x0,0x50,0xe3,0xff,0xff,0x0,0x93,0x0,0xc3,0xd4,0xff,0xff,0x0,0x94,0x0,0x4e,0x18,0x0,0x0,0x0,0x95,0x0,0x88,0x27,0x0,0x0,0x0,0x96,0x0,0x4d,0xeb,0xff,0xff,0x0,0x97,0x0,0xa6,0xdb,0xff,0xff,0x0,0x98,0x0,0xaf,0x11,0x0,0x0,0x0,0x99,0x0,0x96,0x21,0x0,0x0,0x0,0x9a,0x0,0xe0,0xf0,0xff,0xff,0x0,0x9b,0x0,0xdc,0xe0,0xff,0xff,0x0,0x9c,0x0,0xef,0xc,0x0,0x0,0x0,0x9d,0x0,0xf5,0x1c,0x0,0x0,0x0,0x9e,0x0,0xf6,0xf4,0xff,0xff,0x0,0x9f,0x0,0x3,0xe5,0xff,0xff,0x0,0xa0,0x0,0x63,0x9,0x0,0x0,0x0,0xa1,0x0,0x33,0x19,0x0,0x0,0x0,0xa2,0x0,0x10,0xf8,0xff,0xff,0x0,0xa3,0x0,0x70,0xe8,0xff,0xff,0x0,0xa4,0x0,0xa9,0x6,0x0,0x0,0x0,0xa5,0x0,0xd,0x16,0x0,0x0,0x0,0xa6,0x0,0x79,0xfa,0xff,0xff,0x0,0xa7,0x0,0x5a,0xeb,0xff,0xff,0x0,0xa8,0x0,0x87,0x4,0x0,0x0,0x0,0xa9,0x0,0x57,0x13,0x0,0x0,0x0,0xaa,0x0,0x5c,0xfc,0xff,0xff,0x0,0xab,0x0,0xe1,0xed,0xff,0xff,0x0,0xac,0x0,0xda,0x2,0x0,0x0,0x0,0xad,0x0,0xfa,0x10,0x0,0x0,0x0,0xae,0x0,0xda,0xfd,0xff,0xff,0x0,0xaf,0x0,0x19,0xf0,0xff,0xff,0x0,0xb0,0x0,0x85,0x1,0x0,0x0,0x0,0xb1,0x0,0xe2,0xe,0x0,0x0,0x0,0xb2,0x0,0x8,0xff,0xff,0xff,0x0,0xb3,0x0,0x14,0xf2,0xff,0xff,0x0,0xb4,0x0,0x7b,0x0,0x0,0x0,0x0,0xb5,0x0,0x4,0xd,0x0,0x0,0x0,0xb6,0x0,0xf5,0xff,0xff,0xff,0x0,0xb7,0x0,0xd8,0xf3,0xff,0xff,0x0,0xb8,0x0,0xa9,0xff,0xff,0xff,0x0,0xb9,0x0,0x57,0xb,0x0,0x0,0x0,0xba,0x0,0xac,0x0,0x0,0x0,0x0,0xbb,0x0,0x6f,0xf5,0xff,0xff,0x0,0xbc,0x0,0xa,0xff,0xff,0xff,0x0,0xbd,0x0,0xd6,0x9,0x0,0x0,0x0,0xbe,0x0,0x37,0x1,0x0,0x0,0x0,0xbf,0x0,0xde,0xf6,0xff,0xff,0x0,0xc0,0x0,0x94,0xfe,0xff,0xff,0x0,0xc1,0x0,0x7a,0x8,0x0,0x0,0x0,0xc2,0x0,0x9c,0x1,0x0,0x0,0x0,0xc3,0x0,0x28,0xf8,0xff,0xff,0x0,0xc4,0x0,0x3e,0xfe,0xff,0xff,0x0,0xc5,0x0,0x40,0x7,0x0,0x0,0x0,0xc6,0x0,0xe1,0x1,0x0,0x0,0x0,0xc7,0x0,0x50,0xf9,0xff,0xff,0x0,0xc8,0x0,0x6,0xfe,0xff,0xff,0x0,0xc9,0x0,0x27,0x6,0x0,0x0,0x0,0xca,0x0,0xd,0x2,0x0,0x0,0x0,0xcb,0x0,0x5a,0xfa,0xff,0xff,0x0,0xcc,0x0,0xe6,0xfd,0xff,0xff,0x0,0xcd,0x0,0x2c,0x5,0x0,0x0,0x0,0xce,0x0,0x23,0x2,0x0,0x0,0x0,0xcf,0x0,0x47,0xfb,0xff,0xff,0x0,0xd0,0x0,0xd9,0xfd,0xff,0xff,0x0,0xd1,0x0,0x4c,0x4,0x0,0x0,0x0,0xd2,0x0,0x26,0x2,0x0,0x0,0x0,0xd3,0x0,0x1a,0xfc,0xff,0xff,0x0,0xd4,0x0,0xdd,0xfd,0xff,0xff,0x0,0xd5,0x0,0x86,0x3,0x0,0x0,0x0,0xd6,0x0,0x1b,0x2,0x0,0x0,0x0,0xd7,0x0,0xd3,0xfc,0xff,0xff,0x0,0xd8,0x0,0xef,0xfd,0xff,0xff,0x0,0xd9,0x0,0xd9,0x2,0x0,0x0,0x0,0xda,0x0,0x5,0x2,0x0,0x0,0x0,0xdb,0x0,0x75,0xfd,0xff,0xff,0x0,0xdc,0x0,0xa,0xfe,0xff,0xff,0x0,0xdd,0x0,0x43,0x2,0x0,0x0,0x0,0xde,0x0,0xe5,0x1,0x0,0x0,0x0,0xdf,0x0,0x0,0xfe,0xff,0xff,0x0,0xe0,0x0,0x2d,0xfe,0xff,0xff,0x0,0xe1,0x0,0xc2,0x1,0x0,0x0,0x0,0xe2,0x0,0xc0,0x1,0x0,0x0,0x0,0xe3,0x0,0x77,0xfe,0xff,0xff,0x0,0xe4,0x0,0x55,0xfe,0xff,0xff,0x0,0xe5,0x0,0x55,0x1,0x0,0x0,0x0,0xe6,0x0,0x97,0x1,0x0,0x0,0x0,0xe7,0x0,0xd9,0xfe,0xff,0xff,0x0,0xe8,0x0,0x7f,0xfe,0xff,0xff,0x0,0xe9,0x0,0xfc,0x0,0x0,0x0,0x0,0xea,0x0,0x6c,0x1,0x0,0x0,0x0,0xeb,0x0,0x29,0xff,0xff,0xff,0x0,0xec,0x0,0xa8,0xfe,0xff,0xff,0x0,0xed,0x0,0xb7,0x0,0x0,0x0,0x0,0xee,0x0,0x46,0x1,0x0,0x0,0x0,0xef,0x0,0x65,0xff,0xff,0xff,0x0,0xf0,0x0,0xc9,0xfe,0xff,0xff,0x0,0xf1,0x0,0x83,0x0,0x0,0x0,0x0,0xf2,0x0,0x2c,0x1,0x0,0x0,0x0,0xf3,0x0,0x90,0xff,0xff,0xff,0x0,0xf4,0x0,0xd4,0xfe,0xff,0xff,0x0,0xf5,0x0,0x5f,0x0,0x0,0x0,0x0,0xf6,0x0,0x39,0x1,0x0,0x0,0x0,0xf7,0x0,0xb8,0xff,0xff,0xff,0x0,0xf8,0x0,0x97,0xfe,0xff,0xff,0x0,0xf9,0x0,0x1a,0x0,0x0,0x0,0x0,0xfa,0x0,0xce,0x1,0x0,0x0,0x0,0xfb,0x0,0x96,0x0,0x0,0x0,0x0,0xfc,0x0,0x76,0xfd,0xff,0xff,0x0,0xfd,0x0,0x11,0xfc,0xff,0xff,0x0,0xfe,0x0,0x43,0xfd,0xff,0xff,0x0,0xff,0x0,0x32,0xff,0xff,0xff,0x0,0x0,0x3,0x8,0x0,0x0,0x0,0x0};

	for (i = 0; i < 267; i++) {
		memcpy(&cmd[2], &pld[i*7], 9);
		write(sdr14_fd, cmd, 9);
		n = read(sdr14_fd, ack, 3);
	}



}


static void sdr14_set_freq(void)
{
	uint8_t smpl[5] = {0x5, 0x20, 0xb0, 0x00, 0x00};

	uint8_t cmd[10] = {0x0a, 0x00, 0x20, 0x00, 0x00, 0xc0, 0x65, 0x52, 0x00, 0x01};
	uint8_t cmd2[6] = {0x06, 0x00, 0x40, 0x00, 0x00, 0x18};
	uint8_t cmd3[6] = {0x06, 0x00, 0x38, 0x00, 0x00, 0x0};
	uint8_t ack[10] = {0};
	int n;

#if 1
	write(sdr14_fd, smpl, sizeof(smpl));
	n =read(sdr14_fd, smpl, sizeof(smpl));
	printf("acked %d %d\n", n == sizeof(smpl), n);
#endif


	printf("setting 5 MHz NCO freq\n");


	n = write(sdr14_fd, &cmd[0], 10);
	printf("wrote %d\n", n);

	n = myread(10, ack);

	printf("acked %d %x %x %x\n", n, ack[0], ack[1], ack[2],  ack[3]);
#if 1
	write(sdr14_fd, cmd2, sizeof(cmd2));
	n =read(sdr14_fd, cmd2, sizeof(cmd2));
	printf("acked %d %d\n", n == sizeof(cmd2), n);

	write(sdr14_fd, cmd3, sizeof(cmd3));
	n = read(sdr14_fd, cmd3, sizeof(cmd3));
	printf("acked %d\n", n == sizeof(cmd3));
#endif
}





static void fft_init(int n, fftw_plan * p, float **reamin0, float **reamout0)
{
	fftw_complex *in, *out;
	//printf("entering fft_init\n");
	in = (fftw_complex *) fftw_malloc(sizeof(fftw_complex) * n);
	out = (fftw_complex *) fftw_malloc(sizeof(fftw_complex) * n);
	// printf("entering fft_init after malloc %p\n",in);
	*p = fftw_plan_dft_1d(n, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
	*reamin0 = (float *) in;
	*reamout0 = (float *) out;

	// printf("reamin0 %p reamout0 %p\n",reamin0,reamout0);
}

__attribute__((unused))
static void fft_free(fftw_plan * p, float **reamin0, float **reamout0)
{
	fftw_destroy_plan(*p);
	fftw_free((fftw_complex *) * reamin0);
	fftw_free((fftw_complex *) * reamout0);
}

static void cfft(fftw_plan * p)
{
	fftw_execute(*p);
}
	static int once;

/**
 * @brief acquire spectrea
 *
 u @param acq the acquisition configuration
 * @returns 0 on completion, 1 if more acquisitions are pending
 *
 */

static uint32_t sdr14_spec_acquire(void)
{
	int i, j, k;
	int blsiz = NSAM;

	int blsiz2 = blsiz / 2;

	GTimer *timer;
	uint32_t *p;

	double spec[NSAM] = {0};


	struct spec_data *s = NULL;
	struct sdr14_data_pkt pkt;


	timer = g_timer_new();
	g_timer_start(timer);

	/* prepare and send: allocate full length */
	s = g_malloc0(sizeof(struct spec_data) + blsiz * sizeof(uint32_t));

	s->n = blsiz - 31 -31;

	/* XXX fixme, these are just random values */
	s->freq_min_hz = (typeof(s->freq_min_hz)) 0;
	s->freq_max_hz = (typeof(s->freq_max_hz)) (NSAM);
	s->freq_inc_hz = (typeof(s->freq_inc_hz)) (NSAM) / s->n;

	uint8_t oneshot_cmd[8] = {0x08, 0x00, 0x18, 0x00, 0x81, 0x02, 0x00, 0x01};
	uint8_t ack[8];

	uint8_t hbeat[3] = {0x03,0x60,0x00};

	if (!once) {
	write(sdr14_fd, oneshot_cmd, sizeof(oneshot_cmd));

	/*  read ack */
	read(sdr14_fd, ack, sizeof(ack));
	once = 1;
	}

			float rre, aam, aam2, rre2;
	for (k = 0; k < AVG; k++) {

		sdr14_read(&pkt);

		for (j = 0; j < 2* blsiz; j++) {
			reamin0[j] = (double) (pkt.data[j]);
			//printf("%d ", pkt.data[j]); 
		}

//		printf("\n");

		cfft(&p0);

		p = s->spec;

		for (i = 0; i < blsiz; i++) {
#if 0
			for (j = 0; j < blsiz2; j++) {
				re[j] = reamout0[2 * j];
				am[j] = reamout0[2 * j + 1];

			}


			for (i = 0; i < blsiz2; i++) {
				if (i < blsiz2 / 2)
					j = i + blsiz2 / 2;
				else
					j = i - blsiz2 / 2;

				j = i;
				/* note: should sqrt after avg, creates
				 * deviation */
				p[j] += (uint32_t) ((1.0/((float) AVG)) * sqrt(re[i] * re[i] + am[i] * am[i]));
				if (i < 10)
					p[j] = 0;
			}
#endif
#if 1
#if 0
			if (i >= 1) {
				rre = reamout0[2 * i] + reamout0[2 * (blsiz - i)];
				aam = reamout0[2 * i + 1] - reamout0[2 * (blsiz - i) + 1];
				aam2 = -reamout0[2 * i] + reamout0[2 * (blsiz - i)];
				rre2 = reamout0[2 * i + 1] + reamout0[2 * (blsiz - i) + 1];
			} else {
				rre = reamout0[2 * i] + reamout0[0];
				aam = reamout0[2 * i + 1] - reamout0[1];
				aam2 = -reamout0[2 * i] + reamout0[0];
				rre2 = reamout0[2 * i + 1] + reamout0[1];
			}
			(*p) += (uint32_t) ((1.0/((float) AVG)) * sqrt(rre * rre + aam * aam + rre2 * rre2 + aam2 * aam2));
#else
			//(*p) += (uint32_t) ((1.0/((float) AVG)) * sqrt(reamout0[2 * i] * reamout0[2 * i] + reamout0[2 * i + 1] * reamout0[2 * i + 1]) );
			
			if (i < blsiz / 2)
				j = i + blsiz / 2;
			else
				j = i - blsiz / 2;
			
			spec[i] +=   1.0/((float) AVG) * sqrt((reamout0[2 * j] * reamout0[2 * j] + reamout0[2 * j + 1] * reamout0[2 * j + 1]) );
			//(*p) += (uint32_t) ((1.0/((float) AVG)) * sqrt(reamout0[i] * reamout0[i] + reamout0[blsiz -i] * reamout0[blsiz -i]) );
#endif
			p++;
		}
#endif

	}


	write(sdr14_fd, hbeat, sizeof(hbeat));

	g_timer_stop(timer);

#if 1
	for (i = 32; i < s->n-31; i++) {
		s->spec[i] = (uint32_t) (spec[i]);
	}
#else
	for (j = 0; j < s->n; j++) {
		s->spec[j] = (uint32_t) (pkt.data[2*j] + 0x7fff);
	}
#endif

	/* handover for transmission */
	ack_spec_data(PKT_TRANS_ID_UNDEF, s);

	g_free(s);

	g_message(MSG "ACQ: %f sec", g_timer_elapsed(timer, NULL));

	g_timer_destroy(timer);



#if 0
	/* to move to cleanup() or module unload if any... */
	fft_free(&p0, &reamin0, &reamout0);
#endif


	return 1;
}



/**
 * @brief pause/unpause radio acquisition
 *
 */

static void sdr14_spec_acq_enable(gboolean mode)
{
	static gboolean last = TRUE;


	/* see if we currently hold the lock */
	if (mode == last) {

		if (mode)
			ack_spec_acq_enable(PKT_TRANS_ID_UNDEF);
		else
			ack_spec_acq_disable(PKT_TRANS_ID_UNDEF);

		return;
	}

	last = mode;


	if (!mode) {
		g_mutex_lock(&acq_pause);
		return;
	}


	g_mutex_unlock(&acq_pause);

	/* signal the acquisition thread outer loop */
	if (g_mutex_trylock(&acq_lock)) {
		g_cond_signal(&acq_cond);
		g_mutex_unlock(&acq_lock);
	}

	return;
}


/**
 * @brief thread function that does all the spectrum readout work
 */

static gpointer sdr14_spec_thread(gpointer data)
{
	int run;

	while (1) {

		g_mutex_lock(&acq_lock);

		ack_spec_acq_disable(PKT_TRANS_ID_UNDEF);
		g_message(MSG "spectrum acquisition stopped");

		g_cond_wait(&acq_cond, &acq_lock);

		ack_spec_acq_enable(PKT_TRANS_ID_UNDEF);
		g_message(MSG "spectrum acquisition running");

		do {
			if (!g_mutex_trylock(&acq_pause))
				break;

			g_mutex_unlock(&acq_pause);

			g_rw_lock_reader_lock(&obs_rwlock);
			run = sdr14_spec_acquire();
			g_rw_lock_reader_unlock(&obs_rwlock);
		} while (run);


		g_mutex_unlock(&acq_lock);
	}
}


/**
 * @brief spectrum acquisition configuration
 */

G_MODULE_EXPORT
int be_spec_acq_cfg(struct spec_acq_cfg *acq)
{
#if 0
	if (srt_spec_acquisition_configure(acq))
		return -1;
#endif
	return 0;
}


/**
 * @brief current spectrum acquisition configuration readout
 */

G_MODULE_EXPORT
int be_spec_acq_cfg_get(struct spec_acq_cfg *acq)
{
	if (!acq)
		return -1;
#if 0
	memcpy(acq, &g_obs.acq, sizeof(struct spec_acq_cfg));
#endif
	return 0;
}


/**
 * @brief spectrum acquisition enable/disable
 */

G_MODULE_EXPORT
int be_spec_acq_enable(gboolean mode)
{
	once = 0;
	sdr14_spec_acq_enable(mode);

	return 0;
}


/**
 * @brief get telescope spectrometer capabilities
 */

G_MODULE_EXPORT
int be_get_capabilities_spec(struct capabilities *c)
{
	c->freq_min_hz		= 1400000000;
	c->freq_max_hz		= 1430000000;
	c->freq_inc_hz		= 100;
	c->bw_max_hz		= 100;
	c->bw_max_div_lin	= 0;
	c->bw_max_div_rad2	= 1;
	c->bw_max_bins		= 2048;
	c->bw_max_bin_div_lin	= 0;
	c->bw_max_bin_div_rad2	= 0;
	c->n_stack_max		= 0; /* stacking not implemented */

	return 0;
}


/**
 * @brief extra initialisation function
 *
 * @note if a thread is created in g_module_check_init(), the loader appears
 *       to fail, so we do that here
 *
 * @todo figure out if this is an error on our part
 */

G_MODULE_EXPORT
void module_extra_init(void)
{
	if (thread)
		return;


	g_message(MSG "configuring serial link");

	sdr14_fd = sdr14_serial_open_port(sdr14_tty);
	if (!sdr14_fd)
		g_error(MSG "Error opening serial port %s\n", sdr14_tty);

	if (sdr14_serial_set_comm_param(sdr14_fd))
		g_error(MSG "Error setting parameters for serial port %s\n",
			sdr14_tty);


	sdr14_serial_flush(sdr14_fd);
	//sdr14_get_mode();
	sdr14_set_freq();
	sdr14_setup_ad6620();

	g_message(MSG "starting spectrum acquisition thread");

	thread = g_thread_new(NULL, sdr14_spec_thread, NULL);

	/* always start paused */
	sdr14_spec_acq_enable(FALSE);

#if 0
	srt_spec_cfg_defaults();
#endif
}


/**
 * @brief the module initialisation function
 * @note this is called automatically on g_module_open
 */

G_MODULE_EXPORT
const gchar *g_module_check_init(void)
{

        g_message(MSG "initialising module");

	fft_init(NSAM, &p0, &reamin0, &reamout0);

#if 0
	if (srt_spec_load_config())
		g_warning(MSG "Error loading module configuration, this plugin may not function properly.");

	srt_spec_load_calibration();
#endif
	return NULL;
}
